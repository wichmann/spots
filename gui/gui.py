
"""
Main GUI for SPotS.

Main window was generated by calling:
    pyuic4 main_window.ui > main_window.py
    
Created on Sat Oct 18 17:09:11 2014

@author: Christian Wichmann
"""


import logging
import time
from PyQt4 import QtGui
from PyQt4 import QtCore

from main_window import Ui_MainWindow
import change_signal_dialog
from spots import plc
from spots import config


__all__ = ['start_gui']


logger = logging.getLogger('spots.gui')


APP_NAME = 'SPotS'


class SpotsGui(QtGui.QMainWindow, Ui_MainWindow):
    """Main window for SPotS"""
    def __init__(self, parent=None):
        """Initialize main window for SPotS."""
        logger.info('Building main window of SPotS...')
        QtGui.QMainWindow.__init__(self, parent)
        self.setupUi(self)
        # set internal state variables
        self.current_output_image = dict()
        self.current_input_image = dict()
        self.current_program = ''
        self.currently_running_plc = False
        # build main window
        self.setup_widgets()
        self.center_on_screen()
        self.set_signals_and_slots()
        self.update_lists()
        self.setup_plc_timer()

    def setup_widgets(self):
        self.highlighter = IecStHighlighter(self.source_code_editor.document())
        # line number and character offset for last error or an empty tuple if
        # no error is currently present
        self.highlighter.current_error_coordinates = tuple()

    def center_on_screen(self):
        """Centers the window on the screen."""
        screen = QtGui.QDesktopWidget().screenGeometry()
        size = self.geometry()
        self.move((screen.width() - size.width()) / 2,
                  (screen.height() - size.height()) / 2)

    def set_signals_and_slots(self):
        """Sets all signals and slots for main window."""
        self.actionQuit.triggered.connect(QtGui.qApp.quit)
        self.execute_button.clicked.connect(self.on_execute_button)
        # change list items
        self.input_list_view.doubleClicked.connect(self.on_change_input_output)
        self.output_list_view.doubleClicked.connect(self.on_change_input_output)
        self.controller_list_view.doubleClicked.connect(self.on_change_controller)
        # delete list items
        self.remove_controller_button.clicked.connect(self.on_delete_controller)
        self.remove_input_button.clicked.connect(self.on_delete_input)
        self.remove_output_button.clicked.connect(self.on_delete_output)
        # add list items
        self.add_controller_button.clicked.connect(self.on_add_controller)
        self.add_input_button.clicked.connect(self.on_add_input_output)
        self.add_output_button.clicked.connect(self.on_add_input_output)

    def setup_plc_timer(self):
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.run_plc)
        self.timer.start(config.DEFAULT_CYCLE_TIME_MS)

    def run_plc(self):
        start_time = time.time()
        try:
            if self.current_program:
                self.current_input_image = plc.read_input_bits()
                self.current_output_image = plc.process_input_to_output(self.current_program,
                                                                        self.current_input_image)
                plc.write_output_bits(self.current_output_image)
                self.statusbar.showMessage('Running...')
            else:
                self.statusbar.showMessage('Stopped...')
        except SyntaxError as e:
            self.error_message_label.setText('{} on character {} in line {}'.format(e.message, e.offset, e.lineno))
            self.highlighter.current_error_coordinates = (e.lineno, e.offset)
            self.statusbar.showMessage('Syntax error in program. Stopped...')
            return
        except KeyError as e:
            self.error_message_label.setText('Unknown input/output used: {}'.format(e.message))
            self.statusbar.showMessage('Unknown input/output used. Stopped...')
            return
        self.error_message_label.setText('')
        self.update_inputs_and_outputs()
        end_time = time.time()
        logger.debug('Real cycle time: {} ms'.format((end_time - start_time) * 1000))

    @QtCore.pyqtSlot()
    def on_execute_button(self):
        self.current_program = str(self.source_code_editor.toPlainText())

    def update_inputs_and_outputs(self):
        input_string = ''
        for k, v in sorted(self.current_input_image.iteritems()):
            input_string += '{:<5}: \t{}\n'.format(k, v)
        self.input_text_edit.setText(input_string)
        output_string = ''
        for k, v in sorted(self.current_output_image.iteritems()):
            output_string += '{:<5}: \t{}\n'.format(k, v)
        self.output_text_edit.setText(output_string)

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_change_input_output(self, index):
        self.dialog = InputOutputDialog(self, index.data().toString())
        self.dialog.show()
        self.dialog.accepted.connect(self.on_return_from_changing_dialog)

    @QtCore.pyqtSlot()
    def on_change_controller(self):
        logger.error('Changing of controllers not yet implemented!')

    @QtCore.pyqtSlot()
    def on_add_input_output(self):
        self.dialog = InputOutputDialog(self)
        self.dialog.show()
        self.dialog.accepted.connect(self.on_return_from_changing_dialog)

    @QtCore.pyqtSlot()
    def on_add_controller(self):
        logger.error('Adding of controllers not yet implemented!')

    @QtCore.pyqtSlot()
    def on_return_from_changing_dialog(self):
        """Handles the closing of the dialog to change or add new signals.
        A signal can be either an input or an output. If an entry is changed
        the old entry has to be deleted first. After that the new data is added
        to the input and putput lists in module "config".
        """
        # disconnect this from dialog
        self.dialog.accepted.disconnect()
        # check if data was changed
        if self.dialog.old_signal_data != self.dialog.new_signal_data :
            if self.dialog.old_signal_data:
                # changed data -> delete old entry first
                signal_name = self.dialog.old_signal_data[0]
                # using startsWith (pyQt) instead of startswith (Python)!
                if self.dialog.old_signal_data[0].startsWith('O'):
                    del config.OUTPUT_BITS[str(signal_name)]
                elif self.dialog.old_signal_data[0].startsWith('I'):
                    del config.INPUT_BITS[str(signal_name)]
            # add new data
            signal_name = self.dialog.new_signal_data[0]
            signal_address = '{}:{}'.format(self.dialog.new_signal_data[1],self.dialog.new_signal_data[2])
            if self.dialog.new_signal_data[0].startsWith('O'):
                config.OUTPUT_BITS[str(signal_name)] = signal_address
            elif self.dialog.new_signal_data[0].startsWith('I'):
                config.INPUT_BITS[str(signal_name)] = signal_address
        self.update_lists()

    @QtCore.pyqtSlot()
    def on_delete_input(self):
        for item in self.input_list_view.selectedItems():
            name = str(item.text().split(' -> ')[0])
            del config.INPUT_BITS[name]
            self.input_list_view.takeItem(self.input_list_view.row(item))
            logger.debug(config.INPUT_BITS)

    @QtCore.pyqtSlot()
    def on_delete_output(self):
        for item in self.output_list_view.selectedItems():
            name = str(item.text().split(' -> ')[0])
            del config.OUTPUT_BITS[name]
            self.output_list_view.takeItem(self.output_list_view.row(item))
            logger.debug(config.OUTPUT_BITS)

    @QtCore.pyqtSlot()
    def on_delete_controller(self):
        logger.error('Deleting of controllers not yet implemented!')
        #for item in self.controller_list_view.selectedItems():
        #    del plc.CONTROLLER[item.controller_id]
        #    self.controller_list_view.takeItem(self.controller_list_view.row(item))
        #    print(plc.CONTROLLER)

    def update_lists(self):
        self.controller_list_view.clear()
        self.input_list_view.clear()
        self.output_list_view.clear()
        for k, c in plc.CONTROLLER.items():
            item = QtGui.QListWidgetItem(str(c))
            item.controller_id = k
            self.controller_list_view.addItem(item)
        for name, location in config.INPUT_BITS.items():
            string = '{} -> {}'.format(name, location)
            self.input_list_view.addItem(QtGui.QListWidgetItem(string))
        for name, location in config.OUTPUT_BITS.items():
            string = '{} -> {}'.format(name, location)
            self.output_list_view.addItem(QtGui.QListWidgetItem(string))


class InputOutputDialog(QtGui.QDialog, change_signal_dialog.Ui_Dialog):
    """Provides a dialog box to change or add signals. Signals can either be
    inputs or outputs. The dialog is called with a signal id that identifies
    the signal to be changed if one exists.

    After the dialog is closed the old and new signal data can be read as
    tuples 'old_signal_data' and 'new_signal_data'. First string is the signals
    name (e.g. 'I3'), after that follow the name of the controller and the
    address (e.g. number 34).
    """
    def __init__(self, parent=None, signal_id=''):
        super(InputOutputDialog, self).__init__(parent)
        self.signal_to_be_changed = signal_id
        self.setupUi(self)
        self.setup_widgets()
        self.set_signals_and_slots()

    def setup_widgets(self):
        # get data
        if self.signal_to_be_changed:
            # already exiting signal should be changed
            old_signal_name, old_address = self.signal_to_be_changed.split(' -> ')
            old_controller, old_number = old_address.split(':')
            self.old_signal_data = (old_signal_name, old_controller, old_number)
        else:
            self.old_signal_data = tuple()
        # fill combo box
        self.controller_chooser_combo.addItems(config.MODULES.keys())
        # set values for signal if one was given
        if self.signal_to_be_changed:
            index = self.controller_chooser_combo.findText(old_controller)
            self.controller_chooser_combo.setCurrentIndex(index)
            self.signal_name_text.setText(old_signal_name)
            self.signal_address_text.setText(old_number)
        # setup validation etc.
        self.signal_address_text.setValidator(QtGui.QIntValidator(0, 1000))
        self.signal_name_text.setValidator(QtGui.QRegExpValidator(
                                               QtCore.QRegExp('[IO]{1}[0-9]*')))

    def set_signals_and_slots(self):
        self.finished.connect(self.on_close)
        #self.okButton.clicked.connect(self.accept)
        #self.cancelButton.clicked.connect(self.reject)

    def on_close(self):
        new_controller = self.controller_chooser_combo.currentText()
        new_signal_name = self.signal_name_text.text()
        new_number = self.signal_address_text.text()
        self.new_signal_data = (new_signal_name, new_controller, new_number)

    
class IecStHighlighter(QtGui.QSyntaxHighlighter):
    """Provides syntac highlighting for IEC 61131-3 ST source code. Only some
    of the syntax is currently supported!

    Code of this class stolen from pyQt example file!
    """
    def __init__(self, parent=None):
        super(IecStHighlighter, self).__init__(parent)
        self.setup_formats()

    def setup_formats(self):
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["\\btrue\\b", "\\bfalse\\b", "\\band\\b",
                           "\\bor\\b", "\\bnot\\b"]

        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        input_format = QtGui.QTextCharFormat()
        input_format.setFontWeight(QtGui.QFont.Bold)
        input_format.setForeground(QtCore.Qt.red)
        self.highlightingRules.append((QtCore.QRegExp("[I][0-9]+"),
                input_format))

        output_format = QtGui.QTextCharFormat()
        output_format.setFontWeight(QtGui.QFont.Bold)
        output_format.setForeground(QtCore.Qt.blue)
        self.highlightingRules.append((QtCore.QRegExp("[O][0-9]+"),
                output_format))

        self.error_format = QtGui.QTextCharFormat()
        self.error_format.setBackground(QtCore.Qt.yellow)

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.green)
        self.highlightingRules.append((QtCore.QRegExp("//[^\n]*"),
                singleLineCommentFormat))

        self.multiLineCommentFormat = QtGui.QTextCharFormat()
        self.multiLineCommentFormat.setForeground(QtCore.Qt.green)

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""),
                quotationFormat))

        functionFormat = QtGui.QTextCharFormat()
        functionFormat.setFontItalic(True)
        functionFormat.setForeground(QtCore.Qt.blue)
        self.highlightingRules.append((QtCore.QRegExp("\\b[A-Za-z0-9_]+(?=\\()"),
                functionFormat))

        self.commentStartExpression = QtCore.QRegExp("\(\\*")
        self.commentEndExpression = QtCore.QRegExp("\\*\)")

    def highlightBlock(self, text):
        # add all other highlight
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)
            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)
        # add block comment highlight
        self.setCurrentBlockState(0)
        startIndex = 0
        if self.previousBlockState() != 1:
            startIndex = self.commentStartExpression.indexIn(text)
        while startIndex >= 0:
            endIndex = self.commentEndExpression.indexIn(text, startIndex)
            if endIndex == -1:
                self.setCurrentBlockState(1)
                commentLength = len(text) - startIndex
            else:
                commentLength = endIndex - startIndex + self.commentEndExpression.matchedLength()
            self.setFormat(startIndex, commentLength,
                    self.multiLineCommentFormat)
            startIndex = self.commentStartExpression.indexIn(text,
                    startIndex + commentLength);


def start_gui():
    import sys

    app = QtGui.QApplication(sys.argv)
    app.setApplicationName(APP_NAME)

    main = SpotsGui()
    main.show()

    sys.exit(app.exec_())


if __name__ == "__main__":
    start_gui()
