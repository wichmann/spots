
"""
Main GUI for SPotS.

Main window was generated by calling:
    pyuic4 main_window.ui > main_window.py
    
Created on Sat Oct 18 17:09:11 2014

@author: Christian Wichmann
"""


import logging
import time
from PyQt4 import QtGui
from PyQt4 import QtCore

from main_window import Ui_MainWindow
import change_signal_dialog
import change_controller_dialog
from spots import plc
from spots import controller
from spots import config


__all__ = ['start_gui']


logger = logging.getLogger('spots.gui')


APP_NAME = 'SPotS'


class SpotsGui(QtGui.QMainWindow, Ui_MainWindow):
    """Main window for SPotS"""
    def __init__(self, parent=None):
        """Initialize main window for SPotS."""
        logger.info('Building main window of SPotS...')
        QtGui.QMainWindow.__init__(self, parent)
        self.setupUi(self)
        # set internal state variables
        self.current_output_image = dict()
        self.current_input_image = dict()
        self.current_program = ''
        self.currently_running_plc = False
        # build main window
        self.setup_widgets()
        self.center_on_screen()
        self.set_signals_and_slots()
        self.update_lists()
        self.setup_plc_timer()

    def setup_widgets(self):
        self.highlighter = IecStHighlighter(self.source_code_editor.document())
        # line number and character offset for last error or an empty tuple if
        # no error is currently present
        self.highlighter.current_error_coordinates = tuple()

    def center_on_screen(self):
        """Centers the window on the screen."""
        screen = QtGui.QDesktopWidget().screenGeometry()
        size = self.geometry()
        self.move((screen.width() - size.width()) / 2,
                  (screen.height() - size.height()) / 2)

    def set_signals_and_slots(self):
        """Sets all signals and slots for main window."""
        self.actionQuit.triggered.connect(QtGui.qApp.quit)
        self.execute_button.clicked.connect(self.on_execute_button)
        # change list items
        self.input_list_view.doubleClicked.connect(self.on_change_input_output)
        self.output_list_view.doubleClicked.connect(self.on_change_input_output)
        self.controller_list_view.doubleClicked.connect(self.on_change_controller)
        # delete list items
        self.remove_controller_button.clicked.connect(self.on_delete_controller)
        self.remove_input_button.clicked.connect(self.on_delete_input)
        self.remove_output_button.clicked.connect(self.on_delete_output)
        # add list items
        self.add_controller_button.clicked.connect(self.on_add_controller)
        self.add_input_button.clicked.connect(self.on_add_input_output)
        self.add_output_button.clicked.connect(self.on_add_input_output)

    def setup_plc_timer(self):
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.run_plc)
        self.timer.start(config.DEFAULT_CYCLE_TIME_MS)

    def run_plc(self):
        start_time = time.time()
        try:
            if self.current_program:
                self.current_input_image = plc.read_input_bits()
                self.current_output_image = plc.process_input_to_output(self.current_program,
                                                                        self.current_input_image)
                plc.write_output_bits(self.current_output_image)
                self.statusbar.showMessage('Running...')
            else:
                self.statusbar.showMessage('Stopped...')
        except SyntaxError as e:
            self.error_message_label.setText('{} on character {} in line {}'.format(e.message, e.offset, e.lineno))
            self.highlighter.current_error_coordinates = (e.lineno, e.offset)
            self.statusbar.showMessage('Syntax error in program. Stopped...')
            return
        except KeyError as e:
            self.error_message_label.setText('Unknown input/output used: {}'.format(e.message))
            self.statusbar.showMessage('Unknown input/output used. Stopped...')
            return
        self.error_message_label.setText('')
        self.update_inputs_and_outputs()
        end_time = time.time()
        logger.debug('Real cycle time: {} ms'.format((end_time - start_time) * 1000))

    @QtCore.pyqtSlot()
    def on_execute_button(self):
        self.current_program = str(self.source_code_editor.toPlainText())

    def update_inputs_and_outputs(self):
        input_string = ''
        for k, v in sorted(self.current_input_image.iteritems()):
            input_string += '{:<5}: \t{}\n'.format(k, v)
        self.input_text_edit.setText(input_string)
        output_string = ''
        for k, v in sorted(self.current_output_image.iteritems()):
            output_string += '{:<5}: \t{}\n'.format(k, v)
        self.output_text_edit.setText(output_string)

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_change_input_output(self, index):
        self.dialog = InputOutputDialog(self, index.data().toString())
        self.dialog.show()
        self.dialog.accepted.connect(self.on_return_from_changing_dialog)

    @QtCore.pyqtSlot(QtCore.QModelIndex)
    def on_change_controller(self, index):
        controller = self.controller_list_view.item(index.row())
        self.dialog = ControllerDialog(self, controller.controller_id)
        self.dialog.show()
        self.dialog.accepted.connect(self.on_return_from_changing_controller_dialog)

    @QtCore.pyqtSlot()
    def on_add_input_output(self):
        self.dialog = InputOutputDialog(self)
        self.dialog.show()
        self.dialog.accepted.connect(self.on_return_from_changing_dialog)

    @QtCore.pyqtSlot()
    def on_add_controller(self):
        self.dialog = ControllerDialog(self)
        self.dialog.show()
        self.dialog.accepted.connect(self.on_return_from_changing_controller_dialog)

    @QtCore.pyqtSlot()
    def on_return_from_changing_dialog(self):
        """Handles the closing of the dialog to change or add new signals.
        A signal can be either an input or an output. If an entry is changed
        the old entry has to be deleted first. After that the new data is added
        to the input and putput lists in module "config".
        """
        # disconnect this from dialog
        self.dialog.accepted.disconnect()
        # check if data was changed
        if self.dialog.old_signal_data != self.dialog.new_signal_data :
            if self.dialog.old_signal_data:
                # changed data -> delete old entry first
                signal_name = self.dialog.old_signal_data[0]
                # using startsWith (pyQt) instead of startswith (Python)!
                if self.dialog.old_signal_data[0].startsWith('O'):
                    del config.OUTPUT_BITS[str(signal_name)]
                elif self.dialog.old_signal_data[0].startsWith('I'):
                    del config.INPUT_BITS[str(signal_name)]
            # add new data
            signal_name = self.dialog.new_signal_data[0]
            signal_address = '{}:{}'.format(self.dialog.new_signal_data[1],self.dialog.new_signal_data[2])
            if self.dialog.new_signal_data[0].startsWith('O'):
                config.OUTPUT_BITS[str(signal_name)] = signal_address
            elif self.dialog.new_signal_data[0].startsWith('I'):
                config.INPUT_BITS[str(signal_name)] = signal_address
        self.update_lists()

    @QtCore.pyqtSlot()
    def on_return_from_changing_controller_dialog(self):
        """Handles the closing of the dialog to change or add new controller.
        If an entry is changed the old entry has to be deleted first. After
        that the new data is added to the controller list.
        """
        # disconnect this from dialog
        self.dialog.accepted.disconnect()
        # check if data was changed
        if self.dialog.old_controller_data != self.dialog.new_controller_data:
            # get new data from dialog
            new_controller_type = self.dialog.new_controller_data[0]
            # make Python string from QString because this string is key for
            # some dictionaries later!
            new_controller_name = str(self.dialog.new_controller_data[1])
            new_controller_address = self.dialog.new_controller_data[2]
            # check if name was changed
            if self.dialog.old_controller_data:
                old_controller_name = str(self.dialog.old_controller_data[1])
                if old_controller_name != new_controller_name:
                    msgBox = QtGui.QMessageBox()
                    msgBox.setText('You changed the name of this controller. If this change is executed all inputs and outputs associated with this controller will be useless.')
                    msgBox.setInformativeText("Do you want to change the controller name?")
                    msgBox.setStandardButtons(QtGui.QMessageBox.Yes | QtGui.QMessageBox.No)
                    msgBox.setDefaultButton(QtGui.QMessageBox.No)
                    return_value = msgBox.exec_()
                    if return_value == QtGui.QMessageBox.No:
                        return
            # changed data -> delete old entry first
            if self.dialog.old_controller_data:
                del config.CONTROLLER_ADDRESSES[old_controller_name]
                del plc.CONTROLLER[old_controller_name]
            # add new data
            config.CONTROLLER_ADDRESSES[str(new_controller_name)] = new_controller_address
            if new_controller_type == 'Modbus':
                plc.create_controller(controller.CONTROLLER_TYPE.Modbus,
                                      new_controller_name,
                                      config.CONTROLLER_ADDRESSES[new_controller_name])
            elif new_controller_type == 'Dummy':
                plc.create_controller(controller.CONTROLLER_TYPE.Dummy, new_controller_name)
        self.update_lists()

    @QtCore.pyqtSlot()
    def on_delete_input(self):
        for item in self.input_list_view.selectedItems():
            name = str(item.text().split(' -> ')[0])
            del config.INPUT_BITS[name]
            self.input_list_view.takeItem(self.input_list_view.row(item))
            logger.debug(config.INPUT_BITS)

    @QtCore.pyqtSlot()
    def on_delete_output(self):
        for item in self.output_list_view.selectedItems():
            name = str(item.text().split(' -> ')[0])
            del config.OUTPUT_BITS[name]
            self.output_list_view.takeItem(self.output_list_view.row(item))
            logger.debug(config.OUTPUT_BITS)

    @QtCore.pyqtSlot()
    def on_delete_controller(self):
        for item in self.controller_list_view.selectedItems():
            del plc.CONTROLLER[str(item.controller_id)]
            del config.CONTROLLER_ADDRESSES[str(item.controller_id)]
            self.controller_list_view.takeItem(self.controller_list_view.row(item))

    def update_lists(self):
        self.controller_list_view.clear()
        self.input_list_view.clear()
        self.output_list_view.clear()
        for k, c in plc.CONTROLLER.items():
            item = QtGui.QListWidgetItem(str(c))
            item.controller_id = k
            self.controller_list_view.addItem(item)
        for name, location in config.INPUT_BITS.items():
            string = '{} -> {}'.format(name, location)
            self.input_list_view.addItem(QtGui.QListWidgetItem(string))
        for name, location in config.OUTPUT_BITS.items():
            string = '{} -> {}'.format(name, location)
            self.output_list_view.addItem(QtGui.QListWidgetItem(string))


class InputOutputDialog(QtGui.QDialog, change_signal_dialog.Ui_Dialog):
    """Provides a dialog box to change or add signals. Signals can either be
    inputs or outputs. The dialog is called with a signal id that identifies
    the signal to be changed if one exists.

    After the dialog is closed the old and new signal data can be read as
    tuples 'old_signal_data' and 'new_signal_data'. First string is the signals
    name (e.g. 'I3'), after that follow the name of the controller and the
    address (e.g. number 34).
    """
    def __init__(self, parent=None, signal_id=''):
        super(InputOutputDialog, self).__init__(parent)
        self.signal_to_be_changed = signal_id
        self.setupUi(self)
        self.setup_widgets()
        self.set_signals_and_slots()

    def setup_widgets(self):
        # get data
        if self.signal_to_be_changed:
            # already exiting signal should be changed
            old_signal_name, old_address = self.signal_to_be_changed.split(' -> ')
            old_controller, old_number = old_address.split(':')
            self.old_signal_data = (old_signal_name, old_controller, old_number)
        else:
            self.old_signal_data = tuple()
        # fill combo box
        self.controller_chooser_combo.addItems(config.CONTROLLER_ADDRESSES.keys())
        # set values for signal if one was given
        if self.signal_to_be_changed:
            index = self.controller_chooser_combo.findText(old_controller)
            self.controller_chooser_combo.setCurrentIndex(index)
            self.signal_name_text.setText(old_signal_name)
            self.signal_address_text.setText(old_number)
        # setup validation etc.
        self.signal_address_text.setValidator(QtGui.QIntValidator(0, 1000))
        self.signal_name_text.setValidator(QtGui.QRegExpValidator(
                                               QtCore.QRegExp('[IO]{1}[0-9]*')))

    def set_signals_and_slots(self):
        self.finished.connect(self.on_close)

    @QtCore.pyqtSlot()
    def on_close(self):
        new_controller = self.controller_chooser_combo.currentText()
        new_signal_name = self.signal_name_text.text()
        new_number = self.signal_address_text.text()
        self.new_signal_data = (new_signal_name, new_controller, new_number)



class ControllerDialog(QtGui.QDialog, change_controller_dialog.Ui_Dialog):
    """Provides a dialog box to change or add controller. Controller types are
    defined in module "spots.plc". Currently only Modbus controller are
    supported. For testing purposes a dummy controller is also available that
    simulates input signals by generating random bits.

    After the dialog is closed the old and new controller data can be read as
    tuples 'old_controller_data' and 'new_controller_data'. First string is the
    type of the controller, after that follow the name of the controller and
    the ip address.
    """
    def __init__(self, parent=None, controller_id=''):
        """Sets up a dialog to add or change controller setting.

        :param controller_id: id of the controller to be altered or empty
        string if a new controller should be added.
        """
        super(ControllerDialog, self).__init__(parent)
        self.controller_to_be_changed = controller_id
        self.setupUi(self)
        self.setup_widgets()
        self.set_signals_and_slots()

    def setup_widgets(self):
        # get data
        if self.controller_to_be_changed:
            # already exiting controller should be changed
            old_controller = plc.CONTROLLER[self.controller_to_be_changed]
            old_controller_name = old_controller.io_module_name
            if old_controller.controller_type == 1:
                old_controller_type = 'Modbus'
            elif old_controller.controller_type == 2:
                old_controller_type = 'Dummy'
            old_controller_address = old_controller.ip_address
            self.old_controller_data = (old_controller_type, old_controller_name, old_controller_address)
        else:
            self.old_controller_data = tuple()
        # fill combo box
        # TODO fill combo box in a better way!
        self.controller_type_combo.addItem('Modbus')
        self.controller_type_combo.addItem('Dummy')
        # set values for signal if one was given
        if self.controller_to_be_changed:
            index = self.controller_type_combo.findText(str(old_controller_type))
            self.controller_type_combo.setCurrentIndex(index)
            self.controller_name_text.setText(old_controller_name)
            self.ip_address_text.setText(old_controller_address)
            self.update_widget_enablement()
        # setup validation etc.
#        self.signal_address_text.setValidator(QtGui.QIntValidator(0, 1000))
#        self.signal_name_text.setValidator(QtGui.QRegExpValidator(
#                                               QtCore.QRegExp('[IO]{1}[0-9]*')))

    def set_signals_and_slots(self):
        self.finished.connect(self.on_close)
        self.controller_type_combo.currentIndexChanged.connect(self.on_type_changed)

    @QtCore.pyqtSlot()
    def on_close(self):
        new_controller_type = self.controller_type_combo.currentText()
        new_controller_name = self.controller_name_text.text()
        if new_controller_type == 'Modbus':
            new_controller_address = self.ip_address_text.text()
        elif new_controller_type == 'Dummy':
            new_controller_address = ''
        self.new_controller_data = (new_controller_type, new_controller_name,
                                    new_controller_address)

    @QtCore.pyqtSlot()
    def on_type_changed(self):
        self.update_widget_enablement()

    def update_widget_enablement(self):
        new_controller_type = self.controller_type_combo.currentText()
        if new_controller_type == 'Modbus':
            self.ip_address_text.setEnabled(True)
            self.ip_address_label.setEnabled(True)
        elif new_controller_type == 'Dummy':
            self.ip_address_text.setEnabled(False)
            self.ip_address_label.setEnabled(False)


class IecStHighlighter(QtGui.QSyntaxHighlighter):
    """Provides syntac highlighting for IEC 61131-3 ST source code. Only some
    of the syntax is currently supported!

    Code of this class stolen from pyQt example file!
    """
    def __init__(self, parent=None):
        super(IecStHighlighter, self).__init__(parent)
        self.setup_formats()

    def setup_formats(self):
        keywordFormat = QtGui.QTextCharFormat()
        keywordFormat.setForeground(QtCore.Qt.darkBlue)
        keywordFormat.setFontWeight(QtGui.QFont.Bold)

        keywordPatterns = ["\\btrue\\b", "\\bfalse\\b", "\\band\\b",
                           "\\bor\\b", "\\bnot\\b"]

        self.highlightingRules = [(QtCore.QRegExp(pattern), keywordFormat)
                for pattern in keywordPatterns]

        input_format = QtGui.QTextCharFormat()
        input_format.setFontWeight(QtGui.QFont.Bold)
        input_format.setForeground(QtCore.Qt.red)
        self.highlightingRules.append((QtCore.QRegExp("[I][0-9]+"),
                input_format))

        output_format = QtGui.QTextCharFormat()
        output_format.setFontWeight(QtGui.QFont.Bold)
        output_format.setForeground(QtCore.Qt.blue)
        self.highlightingRules.append((QtCore.QRegExp("[O][0-9]+"),
                output_format))

        self.error_format = QtGui.QTextCharFormat()
        self.error_format.setBackground(QtCore.Qt.yellow)

        singleLineCommentFormat = QtGui.QTextCharFormat()
        singleLineCommentFormat.setForeground(QtCore.Qt.green)
        self.highlightingRules.append((QtCore.QRegExp("//[^\n]*"),
                singleLineCommentFormat))

        self.multiLineCommentFormat = QtGui.QTextCharFormat()
        self.multiLineCommentFormat.setForeground(QtCore.Qt.green)

        quotationFormat = QtGui.QTextCharFormat()
        quotationFormat.setForeground(QtCore.Qt.darkGreen)
        self.highlightingRules.append((QtCore.QRegExp("\".*\""),
                quotationFormat))

        functionFormat = QtGui.QTextCharFormat()
        functionFormat.setFontItalic(True)
        functionFormat.setForeground(QtCore.Qt.blue)
        self.highlightingRules.append((QtCore.QRegExp("\\b[A-Za-z0-9_]+(?=\\()"),
                functionFormat))

        self.commentStartExpression = QtCore.QRegExp("\(\\*")
        self.commentEndExpression = QtCore.QRegExp("\\*\)")

    def highlightBlock(self, text):
        # add all other highlight
        for pattern, format in self.highlightingRules:
            expression = QtCore.QRegExp(pattern)
            index = expression.indexIn(text)
            while index >= 0:
                length = expression.matchedLength()
                self.setFormat(index, length, format)
                index = expression.indexIn(text, index + length)
        # add block comment highlight
        self.setCurrentBlockState(0)
        startIndex = 0
        if self.previousBlockState() != 1:
            startIndex = self.commentStartExpression.indexIn(text)
        while startIndex >= 0:
            endIndex = self.commentEndExpression.indexIn(text, startIndex)
            if endIndex == -1:
                self.setCurrentBlockState(1)
                commentLength = len(text) - startIndex
            else:
                commentLength = endIndex - startIndex + self.commentEndExpression.matchedLength()
            self.setFormat(startIndex, commentLength,
                    self.multiLineCommentFormat)
            startIndex = self.commentStartExpression.indexIn(text,
                    startIndex + commentLength);


def start_gui():
    import sys

    app = QtGui.QApplication(sys.argv)
    app.setApplicationName(APP_NAME)

    main = SpotsGui()
    main.show()

    sys.exit(app.exec_())


if __name__ == "__main__":
    start_gui()
